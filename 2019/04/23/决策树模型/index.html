<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>决策树模型 | Jamest</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">决策树模型</h1><a id="logo" href="/.">Jamest</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">决策树模型</h1><div class="post-meta">Apr 23, 2019</div><div class="post-content"><p>决策树的目标是从一组样本数据中，根据不同的特征和属性，建立一棵树形的分类结构。<br><strong>决策树的学习本质上是从训练集中归纳出一组分类规则，得到与数据集矛盾较小的决策树，同时具有很好的泛化能力。<font color="red">决策树学习的损失函数通常是正则化的极大似然函数</font></strong>，通常采用启发式方法，近似求解这一最优化问题。<br><a id="more"></a></p>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><h3 id="ID3-最大信息增益"><a href="#ID3-最大信息增益" class="headerlink" title="ID3-最大信息增益"></a>ID3-<font color="red">最大信息增益</font></h3><p>对于样本集合D，类别数为K，数据集D的经验熵表示为:<br>$$<br>H(D)=-\sum_{k=1}^K\frac{|C_k |}{|D|} \log_2{\frac{|C_k |}{|D|}}<br>$$<br>其中$C_k$是样本集合$D$中属于第$k$类的样本子集，$|C_k|$表示该子集的元素个数，$|D|$表示元素集合的元素个数。<br>某个特征$A$对于数据集$D$的经验条件熵$H(D|A)$为<br>$$<br>H(D|A)=\sum_{i=1}^N\frac{|D_i|}{|D|}H(D_i)<br>$$<br>其中$D_i$表示$D$中特征$A$取第$i$个值的样本子集。<br>信息增益$g(D,A)$为：<br>$$<br>g(D,A)=H(D)-H(D|A)<br>$$</p>
<h3 id="C4-5-最大信息增益比"><a href="#C4-5-最大信息增益比" class="headerlink" title="C4.5-最大信息增益比"></a>C4.5-<font color="red">最大信息增益比</font></h3><p>信息增益比为：<br>$$<br>g_R(D,A)=\frac{g(D,A)}{H_A(D)}<br>$$<br>其中，<br>$$<br>H_A(D)=-\sum_{i=1}^N\frac{|D_i|}{|D|}\log_2{\frac{|D_i|}{|D|}}<br>$$</p>
<h3 id="CART-最大基尼指数（Gini）"><a href="#CART-最大基尼指数（Gini）" class="headerlink" title="CART-最大基尼指数（Gini）"></a>CART-<font color="red">最大基尼指数（Gini）</font></h3><p>Gini描述的是数据的纯度，与信息熵含义类似<br>$$<br>Gini(D)=1-\sum_{k=1}^N{(\frac{|C_k|}{|D|})}^2<br>$$<br>CART树在每一次迭代中选择基尼指数最小的特征及其对应的切分点进行分类。与ID3、C4.5不同的是，CART时一颗二叉树，采用二元切割法，每一步将数据按特征A的取值切成两份，分别进入左右子树。特征A的Gini指数定义为：<br>$$<br>Gini(D|A)=1-\sum_{k=1}^N\frac{|D_i|}{|D|}Gini(D_i )<br>$$</p>
<h3 id="联系与比较"><a href="#联系与比较" class="headerlink" title="联系与比较"></a>联系与比较</h3><p>ID3倾向于取值较多的特征，因为信息增益反映的是给定条件以后不确定性减少的程度，特征取值越多就意味着确定性更高，也就是条件熵越小，信息增益越大。<br>从样本类型的角度，ID3只能处理离散型变量，而C4.5和CART都可以处理连续型变量。从应用的角度，ID3和C4.5只能用于分类任务，而CART也可以用于回归任务（使用最小平方误差准则）。</p>
<h2 id="剪枝方法"><a href="#剪枝方法" class="headerlink" title="剪枝方法"></a>剪枝方法</h2><ul>
<li>预剪枝：通过提前停止构建而对树“剪枝”，一旦停止，节点就成为树叶。（停止生长的方法：定义高度、达到某个节点实例具有相同的特征向量、定义阈值）。<br>预剪枝方法相对简单，效率高，而且不需要生成整个决策树，适合解决大规模问题。但是何时停止不好确定，阈值不好确定，高阈值可能导致过分简化的树，而低阈值可能使得树的简化太少。</li>
<li>后剪枝：它首先构造完整的决策树，允许过树过度拟合训练数据，然后对那些置信度不够的节点子树用叶子节点来代替。<br>相比于预剪枝，后剪枝方法通常可以得到泛化能力更强的决策树，但时间开销会更大。</li>
</ul>
<h2 id="分类树与回归树"><a href="#分类树与回归树" class="headerlink" title="分类树与回归树"></a>分类树与回归树</h2><ol>
<li>分类树<br>以C4.5分类树为例，C4.5分类树在每次分枝时，是穷举每一个feature的每一个阈值，找到使得按照feature&lt;=阈值，和feature&gt;阈值分成的两个分枝的熵最大的阈值(熵最大的概念可理解成尽可能每个分枝的男女比例都远离1:1)，按照该标准分枝得到两个新节点，用同样方法继续分枝直到所有人都被分入性别唯一的叶子节点，或达到预设的终止条件，若最终叶子节点中的性别不唯一，则以多数人的性别作为该叶子节点的性别。<br>总结：分类树使用信息增益或增益比率来划分节点；每个节点样本的类别情况投票决定测试样本的类别。</li>
<li>回归树<br>回归树总体流程也是类似，区别在于，回归树的每个节点（不一定是叶子节点）都会得一个预测值，以年龄为例，该预测值等于属于这个节点的所有人年龄的平均值。分枝时穷举每一个feature的每个阈值找最好的分割点，但衡量最好的标准不再是最大熵，而是最小化均方差即(每个人的年龄-预测年龄)^2 的总和 / N。也就是被预测出错的人数越多，错的越离谱，均方差就越大，通过最小化均方差能够找到最可靠的分枝依据。分枝直到每个叶子节点上人的年龄都唯一或者达到预设的终止条件(如叶子个数上限)，若最终叶子节点上人的年龄不唯一，则以该节点上所有人的平均年龄做为该叶子节点的预测年龄。<br><strong><font color="red">总结：回归树使用最大均方差划分节点；每个节点样本的均值作为测试样本的回归预测值。</font></strong></li>
</ol>
<h2 id="决策树损失函数"><a href="#决策树损失函数" class="headerlink" title="决策树损失函数"></a>决策树损失函数</h2><p><strong><font color="red">决策树的损失函数通常是正则化的极大似然函数。</font></strong><br>为了避免出现过拟合的现象，我们要对决策树进行剪枝。<br>决策树损失函数为：<br>$$<br>C_α (T)=\sum_{t=1}N_t H_t (T)+α|T|<br>$$<br>右边第一项表示误差大小，第二项表示模型的复杂度，也就是用叶节点表示，防止过拟化。其中$|T|$代表叶节点个数，$N_t$表示具体某个叶节点的样例数，$H_t (T)$表示叶节点经验熵。<br>其中，叶节点经验熵为<br>$$<br>H_t (T)=-\sum_{k=1}^K\frac{N_{tk}}{N_t}\log⁡{\frac{N_{tk}}{N_t}}<br>$$<br>其中，$N_t$表示该叶节点有$N_t$个样本，其中$k$类的样本有$N_{tk}$个。<br>正则化的损失函数中前一项代表经验误差，而在概率模型中(决策树模型是一种概率模型)，经验误差函数的获得往往通过将极大似然函数取反，即将求极大化为求极小而获得。因此，在概率模型中，极大似然函数与经验误差函数可以认为是相同的概念，那么必然就可以通过经验误差函数来推导出极大似然函数，以此来加深对决策树损失函数的理解。<br>$$<br>\begin{aligned}<br>\sum_{t=1}N_t H_t (T)=&amp;<br>-\sum_{t=1}\sum_{k=1}^K\frac{N_{tk}}{N_t}\log⁡{\frac{N_{tk}}{N_t}}*N_t \\<br>=&amp;-\sum_{t=1}\sum_{k=1}^K{N_{tk}}\log⁡{\frac{N_{tk}}{N_t}} \\<br>=&amp;-\log\prod_{t=1}^{|T|}\prod_{k=1}^{K}{(\frac{N_{tk}}{N_t})}^{N_{tk}} \\<br>\end{aligned}<br>$$<br>至此，损失函数被化简如上，可以看到它与我们所要求的极大似然函数仅一步之遥：将求极小转为求极大，即去掉上式的负号，我们得到对数极大似然函数：<br>$$<br>L(T) = \log\prod_{t=1}^{|T|}\prod_{k=1}^{K}{(\frac{N_{tk}}{N_t})}^{N_{tk}}<br>$$<br>其对应的极大似然函数是<br>$$<br>L(T) = \prod_{t=1}^{|T|}\prod_{k=1}^{K}{(\frac{N_{tk}}{N_t})}^{N_{tk}}<br>$$<br>至此，决策树模型的极大似然函数推导完毕。<br>其意义个人理解为：<strong>先对各叶节点之间进行极大似然估计，再对各叶节点内部进行极大似然估计，由此得到决策树模型中的极大似然函数。</strong></p>
<h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><blockquote>
<p>决策树处理连续值的方法</p>
</blockquote>
<p>因为连续属性的可取值数目不再有限，因此不能像前面处理离散属性枚举离散属性取值来对结点进行划分。因此需要连续属性离散化，常用的离散化策略是二分法，这个技术也是C4.5中采用的策略。<br>对连续属性的处理如下<br>1、对特征的取值进行升序排序<br>2、两个特征取值之间的中点作为可能的分裂点，将数据集分成两部分，计算每个可能的分裂点的信息增益（InforGain）。优化算法就是只计算分类属性发生改变的那些特征取值。<br>3、选择修正后信息增益(InforGain)最大的分裂点作为该特征的最佳分裂点<br>4、计算最佳分裂点的信息增益率（Gain Ratio）作为特征的Gain Ratio。注意，此处需对最佳分裂点的信息增益进行修正：减去log2(N-1)/|D|（N是连续特征的取值个数，D是训练数据数目，此修正的原因在于：当离散属性和连续属性并存时，C4.5算法倾向于选择连续特征做最佳树分裂点）</p>
<blockquote>
<p>决策树处理缺失值的方法</p>
</blockquote>
<p>1、采用抛弃缺失值<br>抛弃极少量的缺失值的样本对决策树的创建影响不是太大。但是如果属性缺失值较多或是关键属性值缺失,创建的决策树将是不完全的,同时可能给用户造成知识上的大量错误信息,所以抛弃缺失值一般不采用。只有在数据库具有极少量的缺失值同时缺失值不是关键的属性值时,且为了加快创建决策树的速度,才采用抛弃属性缺失值的方式创建决策树。<br>2、补充缺失值<br>缺失值较少时按照我们上面的补充规则是可行的。但如果数据库的数据较大,缺失值较多(当然,这样获取的数据库在现实中使用的意义已不大,同时在信息获取方面基本不会出现这样的数据库),这样根据填充后的数据库创建的决策树可能和根据正确值创建的决策树有很大变化。<br>3、概率化缺失值<br>对缺失值的样本赋予该属性所有属性值的概率分布,即将缺失值按照其所在属性已知值的相对概率分布来创建决策树。用系数F进行合理的修正计算的信息量,F=数据库中缺失值所在的属性值样本数量去掉缺失值样本数量/数据库中样本数量的总和,即F表示所给属性具有已知值样本的概率。<br>4、缺失值单独分支</p>
<blockquote>
<p>为什么C4.5要用信息增益率代替信息增益？为什么信息增益会偏向多取值特征？</p>
</blockquote>
<p>信息增益在面对类别较少的离散数据时效果较好，但是面对取值较多的特征时效果会很不如人意。关于信息增益对取值较多特征的偏向性，我认为原因是：当特征的取值较多时，根据此特征划分得到的子集纯度有更大的可能性会更高(对比与取值较少的特征)，因此划分之后的熵更低，由于划分前的熵是一定的，因此信息增益更大，因此信息增益比较偏向取值较多的特征。举个较为极端的例子可能更好理解：如果特征A的取值能将每一个样本都分到一个节点当中去的时候(如编号等特征)，条件熵部分会为0，这意味着该情况下的信息增益达到了最大值，故ID3算法一定会选择特征A。但是，显然的，我们知道这个特征A显然不是最佳选择。</p>
</div><div class="tags"><a href="/tags/algorithms/">algorithms</a></div><div class="post-nav"><a class="pre" href="/2019/04/23/机器学习基础问题/">机器学习基础概念</a><a class="next" href="/2019/04/22/支持向量机模型/">支持向量机模型</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/algorithms/" style="font-size: 15px;">algorithms</a> <a href="/tags/machine-learning/" style="font-size: 15px;">machine learning</a> <a href="/tags/Algorithm-practice/" style="font-size: 15px;">Algorithm practice</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/04/EM算法/">EM算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/03/降维算法一览/">降维算法一览</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/29/xgboost-lightgbm调参指南/">xgboost&lightgbm调参指南</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/24/集成学习/">集成学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/23/机器学习基础问题/">机器学习基础概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/23/决策树模型/">决策树模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/22/支持向量机模型/">支持向量机模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/逻辑回归模型/">逻辑回归模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/19/最大熵模型/">最大熵模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/22/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://github.com/helloJamest" title="github" target="_blank">github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Jamest.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" color="0,0,0" opacity="0.5" zindex="-2" count="50" src="//lib.baomitu.com/canvas-nest.js/2.0.3/canvas-nest.umd.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>