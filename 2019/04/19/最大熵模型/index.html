<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>最大熵模型 | Jamest</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">最大熵模型</h1><a id="logo" href="/.">Jamest</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">最大熵模型</h1><div class="post-meta">Apr 19, 2019</div><div class="post-content"><p>最大熵模型是指在满足约束条件的模型集合中选取熵最大的模型，即不确定性最大的模型。<br><a id="more"></a></p>
<h2 id="最大熵原理"><a href="#最大熵原理" class="headerlink" title="最大熵原理"></a>最大熵原理</h2><p><strong>最大熵思想</strong>：当你要猜一个概率分布时，如果你对这个分布一无所知，那就猜熵最大的均匀分布，如果你对这个分布知道一些情况，那么，就猜满足这些情况的熵最大的分布。</p>
<h2 id="算法推导"><a href="#算法推导" class="headerlink" title="算法推导"></a>算法推导</h2><p>按照最大熵原理,我们应该优先保证模型满足已知的所有约束。那么如何得到这些约束呢?<br>思路是:从训练数据$T$中抽取若干特征,然后要求这些特征在$T$上关于经验分布的期望与它们在模型中关于$p(x,y)$的数学期望相等,这样,一个特征就对应一个约束。<br>假设训练集为$T={(x1,y1),(x2,y2),…,(xn,yn)}$。则联合分布$P(x,y)$的经验分布和边缘分布$P(x)$的经验分布为：</p>
<script type="math/tex; mode=display">\tilde{P}(x,y)=\tilde{P}(X=x,Y=y)=\frac{count(x,y)}{N}</script><script type="math/tex; mode=display">\tilde{P}(x)=\tilde{P}(X=x)=\frac{count(x)}{N}</script><p>我们定义特征函数</p>
<script type="math/tex; mode=display">f(x,y)=
\begin{cases}
1& \text{x,y满足某一事实}\\
0& \text{否则}
\end{cases}</script><p>设$E_{\tilde{P}}(f)$：表示特征函数$f$在训练数据$T$上关于$\tilde{P}(x,y)$的数学期望：</p>
<script type="math/tex; mode=display">E_{\tilde{P}}(f)=\sum_{x,y}{\tilde{P}(x,y)f(x,y)}</script><p>设$E_p(f)$：表示特征函数$f$在模型上关于$P(x,y)$的数学期望</p>
<script type="math/tex; mode=display">E_(f)=\sum_{x,y}{P(x,y)f(x,y)} =\sum_{x,y}{P(x)P(y|x)f(x,y)}</script><p>由于$P(x)$是未知的，我们使用$\tilde{P}(x)$来近似表示。于是有</p>
<script type="math/tex; mode=display">E_(f)=\sum_{x,y}{\tilde{P}(x)P(y|x)f(x,y)}</script><p><strong>最终我们需要计算的条件概率为：$P(Y|X)$。</strong><br>我们的条件熵为：</p>
<script type="math/tex; mode=display">
H(P) = -\sum_{x,y}P(x)P(y|x)\log{P(y|x)}</script><p>同样，我们需要将$P(x)$的值进行近似处理：</p>
<script type="math/tex; mode=display">
H(P) = -\sum_{x,y}\tilde{P}(x)P(y|x)\log{P(y|x)}</script><p>另外，对于任意输入样例，它总是属于某一个输出类别，因而</p>
<script type="math/tex; mode=display">
\sum_{y}P(y|x)=1</script><p>因此，现在我们将上述问题转变成了一个有条件的最优化问题：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\max\ \ &{H(P)= -\sum_{x,y}\tilde{P}(x)P(y|x)\log{P(y|x)}}\\
s.t.\ \ &E_{P}(f)=E_{\tilde{P}}(f)\\
&\sum_{y}P(y|x)=1
\end{aligned}</script><p>即，</p>
<script type="math/tex; mode=display">
\begin{aligned}
\min\ \ &{-H(P)= \sum_{x,y}\tilde{P}(x)P(y|x)\log{P(y|x)}}\\
s.t.\ \ &E_{P}(f)=E_{\tilde{P}}(f)\\
&\sum_{y}P(y|x)=1
\end{aligned}</script><p>这里，将约束最小化的原始问题转换为无约束最优化的对偶问题，通过对偶问题来求解原始问题。<br>首先，引入拉格朗日乘子$w_0,w_1,…,w_n$，定义拉格朗日函数$L(P,w)$,</p>
<script type="math/tex; mode=display">
\begin{aligned}
L(P,w)=&-H(P)+w_0\left(1-\sum_y{P(y|x)}\right)+\sum_{i=1}^n{w_i(E_{\tilde{P}}(f_i)-E_{P}(f_i))}\\
=&\sum_{x,y}\tilde{P}(x)P(y|x)\log{P(y|x)}+w_0\left(1-\sum_y{P(y|x)}\right)+\sum_{i=1}^n{w_i(E_{\tilde{P}}(f_i)-E_{P}(f_i))}
\end{aligned}</script><p>最优化原始问题的对偶问题是：</p>
<script type="math/tex; mode=display">
\max_w{\min_P{L(P,w)}}</script><p>由于$L(P,w)$是$P$的凸函数，原始问题的解与对偶问题的解是等价的。<br>将$L(P,w)$对$P(y│x)$求偏导数，得</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial L(P,w)}{\partial P(y│x)}=&\sum_{x,y}{\tilde{P}(x)(\log{P(y|x)}}+1)-\sum_y{w_0}-\sum_{x,y}(\tilde{P}(x)\sum_{i=1}^nw_if_i(x,y))\\
=&\sum_{x,y}\tilde{P}(x)\left(\log{P(y|x)}+1-w_0-\sum_i^nw_if_i(x,y)\right)
\end{aligned}</script><p>令偏导数为0，解得</p>
<script type="math/tex; mode=display">
\begin{aligned}
P(y|x)=&\exp({\sum_{i=1}^nw_if_i(x,y)+w_0-1})\\
=&\exp({\sum_{i=1}^nw_if_i(x,y)})\exp({w_0-1})
\end{aligned}</script><p>由于</p>
<script type="math/tex; mode=display">
\sum_{y}P(y|x)=1</script><p>有，</p>
<script type="math/tex; mode=display">
\sum_{y}P(y|x)=\sum_{y}\exp({\sum_{i=1}^nw_if_i(x,y)})\exp({w_0-1})=1</script><p>得，</p>
<script type="math/tex; mode=display">
\exp({w_0-1})=\frac{1}{\sum_{y}\exp({\sum_{i=1}^nw_if_i(x,y)})}</script><p>令规范化因子$Z_w (x)$为</p>
<script type="math/tex; mode=display">
Z_w(x)=\sum_{y}\exp({\sum_{i=1}^nw_if_i(x,y)})</script><p>此时得到对偶问题的极小解为：</p>
<script type="math/tex; mode=display">
P_w(y|x)=\frac{1}{Z_w(x)}e^{\sum_{i=1}^nw_if_i(x,y)}</script><p>这就是我们所需要的最大熵模型下的概率估计。<br>我们再回顾下推导流程，</p>
<ul>
<li>首先定义我们的约束条件：1、定义特征函数，约束为其在数据集上关于经验分布的期望与它们在模型中的数学期望相等；2、关于x的条件概率总和为1。</li>
<li>确定我们的目标：最大化在条件概率分布$P(Y|X)$上的条件熵，在约束上构建构建我们的最优化问题。</li>
<li>引进拉格朗日乘子，定义拉格朗日函数，通过求解对偶问题来求解原始问题。</li>
</ul>
<blockquote>
<font color="red">实际上，对偶问题的极大化等价于最大熵模型的极大似然估计。</font>

</blockquote>
<p>至此，我们已经得到了最大熵模型的目标估计，而模型中的最优参数则是对偶问题最大时的参数。<br>具体学习算法有改进的迭代尺度法（IIS）与拟牛顿法。</p>
<h2 id="最大熵与逻辑回归"><a href="#最大熵与逻辑回归" class="headerlink" title="最大熵与逻辑回归"></a>最大熵与逻辑回归</h2><p>逻辑回归是最大熵对应类别为两类时的特殊情况，也就是当逻辑回归类别扩展到多类别时，就是最大熵。<br>其联系在于：指数簇分布的最大熵等价于其指数形式的最大似然界；二项式的最大熵解等价于二项式指数形式(sigmoid)的最大似然，多项式分布的最大熵等价于多项式分布指数形式(softmax)的最大似然。</p>
<blockquote>
<p>因此为什么用sigmoid函数，那是因为指数簇分布最大熵的特性的必然性。</p>
</blockquote>
<p>另外，逻辑回归模型与最大熵模型都属于对数线性模型。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li><p>最大熵模型的优点有：</p>
<ul>
<li>最大熵统计模型获得的是所有满足约束条件的模型中信息熵极大的模型,作为经典的分类模型时准确率较高。</li>
<li>可以灵活地设置约束条件，通过约束条件的多少可以调节模型对未知数据的适应度和对已知数据的拟合程度。</li>
</ul>
</li>
<li><p>最大熵模型的缺点有：</p>
<ul>
<li>由于约束函数数量和样本数目有关系，导致迭代过程计算量巨大，实际应用比较难。</li>
</ul>
</li>
</ul>
</div><div class="tags"><a href="/tags/algorithms/">algorithms</a></div><div class="post-nav"><a class="pre" href="/2019/04/21/逻辑回归模型/">逻辑回归模型</a><a class="next" href="/2019/01/22/hello-world/">Hello World</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/algorithms/" style="font-size: 15px;">algorithms</a> <a href="/tags/machine-learning/" style="font-size: 15px;">machine learning</a> <a href="/tags/Algorithm-practice/" style="font-size: 15px;">Algorithm practice</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/04/聚类算法一览/">聚类算法一览</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/04/EM算法/">EM算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/03/降维算法一览/">降维算法一览</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/29/xgboost-lightgbm调参指南/">xgboost&lightgbm调参指南</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/24/集成学习/">集成学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/23/机器学习基础问题/">机器学习基础概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/23/决策树模型/">决策树模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/22/支持向量机模型/">支持向量机模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/逻辑回归模型/">逻辑回归模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/19/最大熵模型/">最大熵模型</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="https://github.com/helloJamest" title="github" target="_blank">github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Jamest.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" color="0,0,0" opacity="0.5" zindex="-2" count="50" src="//lib.baomitu.com/canvas-nest.js/2.0.3/canvas-nest.umd.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>