<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>百面机器学习 | Jamest</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">百面机器学习</h1><a id="logo" href="/.">Jamest</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">百面机器学习</h1><div class="post-meta">May 6, 2019</div><div class="post-content"><p>百面机器学习是一本记录面试问题的书，一方面，学习里面的问题和解答有助于我们更好的掌握机器学习，另一方面，以目录为索引，可以扩展我们的知识面，掌握应届生从事机器学习必备的技能。下面以章节为单位，记录书本的大纲内容。<br><a id="more"></a></p>
<h1 id="第1章-特征工程"><a href="#第1章-特征工程" class="headerlink" title="第1章 特征工程"></a>第1章 特征工程</h1><h2 id="01-为什么要对数值类型的特征做归一化？"><a href="#01-为什么要对数值类型的特征做归一化？" class="headerlink" title="01 为什么要对数值类型的特征做归一化？"></a>01 为什么要对数值类型的特征做归一化？</h2><p>对数值类型的特征做归一化可以<strong>将所有特征统一到一个大致相同的区间，加快梯度下降更新速度</strong>。最常用的有：<strong>线性函数归一化（Min-Max Scaling）</strong>（将原始数据映射到[0,1]的范围）以及<strong>零均值归一化（Z-Score Normalizaation）</strong>（将原始数据映射到均值为0、标准差为1的分布上）。<br>1、在分类、聚类算法中，需要使用距离来度量相似性的时候、或者使用PCA技术进行降维的时候，第二种方法(Z-score standardization)表现更好。<br>2、在不涉及距离度量、协方差计算、数据不符合正太分布的时候，可以使用第一种方法或其他归一化方法。比如图像处理中，将RGB图像转换为灰度图像后将其值限定在[0 255]的范围。</p>
<h2 id="02-怎样处理类别型特征？"><a href="#02-怎样处理类别型特征？" class="headerlink" title="02 怎样处理类别型特征？"></a>02 怎样处理类别型特征？</h2><p>序号编码、独热编码、二进制编码</p>
<h2 id="03-什么是组合特征？如何处理高维组合特征？"><a href="#03-什么是组合特征？如何处理高维组合特征？" class="headerlink" title="03 什么是组合特征？如何处理高维组合特征？"></a>03 什么是组合特征？如何处理高维组合特征？</h2><p>为了提高复杂关系的拟合能力，在特征工程中经常会把一阶离散特征两两组合，构成高阶组合特征。</p>
<h2 id="04-怎样高效地找到组合特征？"><a href="#04-怎样高效地找到组合特征？" class="headerlink" title="04 怎样高效地找到组合特征？"></a>04 怎样高效地找到组合特征？</h2><p>基于决策树的特征组合寻找方法。</p>
<h2 id="05-有那些文本表示模型？它们各有什么优缺点？"><a href="#05-有那些文本表示模型？它们各有什么优缺点？" class="headerlink" title="05 有那些文本表示模型？它们各有什么优缺点？"></a>05 有那些文本表示模型？它们各有什么优缺点？</h2><ul>
<li><font color="red">词袋模型和N-gram模型</font><br>忽略每个词出现的顺序，将整段文本以词为单位切分，将每篇文章表示成一个长向量。常用$TF-IDF$来计算权重，公式为：$TF-IDF(t,d) = TF(t,d)*IDF(t)$。$TF(t,d)$为单词t在文档d中的频率，$IDF(t）$为逆文档频率，用来衡量单词t对表达语义所起的重要性，表示为$IDF(t) = log(文章总数/包含单词t的文章总数+1)$。<br>$N-gram$是将连续出现的n个词（n&lt;=N）组成的词组作为一个单独的特征放到向量表示中。另外，同一个词有多种词性变化，可以进行词干抽取（Word Stemming）处理。</li>
<li><font color="red">主题模型</font><br>主题模型用于从文本库中发现有代表性的主题（得到每个主题上面词的分布特性），并且能计算出每篇文章的主题分布。</li>
<li><font color="red">词嵌入与深度学习模型</font><br>词嵌入是一类将词向量化的模型的统称，核心思想是将每个词都映射成低维空间（通常50-300维）上的一个稠密向量。</li>
</ul>
<h2 id="06-Word2Vec-是如何工作的？它和隐狄利克雷模型（LDA）有什么区别与联系？"><a href="#06-Word2Vec-是如何工作的？它和隐狄利克雷模型（LDA）有什么区别与联系？" class="headerlink" title="06 Word2Vec 是如何工作的？它和隐狄利克雷模型（LDA）有什么区别与联系？"></a>06 Word2Vec 是如何工作的？它和隐狄利克雷模型（LDA）有什么区别与联系？</h2><p><font color="red">Word2Vec有两种网络结构</font>。<strong>CBOW(Continues Bag of Words)的目标是根据上下文出现的词语来预测当前词的生成概率；Skip-gram是根据当前词来预测上下文中个词的生成概率。CBOW对小型数据库比较合适，而Skip-Gram在大型语料中表现更好。</strong><br>word2Vec与LDA的区别和联系。 <strong>LDA是利用文档中单词的共现关系来对单词按主题聚类，即对‘文档-单词’矩阵进行分解，而word2Vec是对‘上下文-单词’矩阵进行学习，由此得到的词向量更多融入了上下文共现的特征。</strong> 需要注意，上述分析的LDA和Word2Vec的不同，不是主题模型和词嵌入两种方法的主要差异。其主要差异在于其模型本身，主题模型是一种基于概率图模型的生成式模型，其似然函数可以写成若干条件概率连乘的形式；而词嵌入一般表达为神经网络的形式，似然函数定义在网络输出之上，需要通过学习网络权重来得到单词的稠密向量表示。</p>
<h2 id="07-如何缓解图像分类任务中训练数据不足带来的问题？"><a href="#07-如何缓解图像分类任务中训练数据不足带来的问题？" class="headerlink" title="07 如何缓解图像分类任务中训练数据不足带来的问题？"></a>07 如何缓解图像分类任务中训练数据不足带来的问题？</h2><p>当训练数据不足，主要表现为过拟合。缓解方法是加入更多的先验信息，主要在两方面：一、基于模型的方法，包括简化模型、添加正则项以缩小假设空间、集成学习、Dropout超参数；二、基于数据的方法，主要通过数据扩充（Data Augmentation），例如图像增强、SMOTE算法、生成式对抗网络模型、迁移学习等。</p>
<h1 id="第2章-模型评估"><a href="#第2章-模型评估" class="headerlink" title="第2章 模型评估"></a>第2章 模型评估</h1><h2 id="08-准确率的局限性"><a href="#08-准确率的局限性" class="headerlink" title="08 准确率的局限性"></a>08 准确率的局限性</h2><p>当不同类别的样本比率非常不均衡时，占比大的类别往往成为影响准确率的最主要因素。并且可能存在模型过拟合或者欠拟合、测试集和训练集划分不合理、线下评估与线上测试的样本分布存在差异等问题。</p>
<h2 id="09-精确率与召回率的权衡"><a href="#09-精确率与召回率的权衡" class="headerlink" title="09 精确率与召回率的权衡"></a>09 精确率与召回率的权衡</h2><p>精确率是指分类正确的正样本个数占分类器判定为正样本的样本个数的比例。召回率是指分类正确的正样本个数占真正的正样本个数的比率。<br><strong><font color="red">模型P-R曲线，横轴是召回率，纵轴是精确率</font></strong>，对于一个排序模型来说，其P-R曲线上的一个点代表着，在某一阈值下，模型将大于该阈值的结果判定为正样本，小于该阈值的结果判定为负样本，此时对应的精确率和召回率。整体P-R曲线是通过将阈值从高到低移动而生成的。<br>F1 = 2<em>P</em>R/(P+R)<br>TP: 将正类预测为正类数 40<br>FN: 将正类预测为负类数 20<br>FP: 将负类预测为正类数 10<br>TN: 将负类预测为负类数 30<br>准确率(accuracy) = 预测对的/所有 = (TP+TN)/(TP+FN+FP+TN)<br>精确率(precision) = TP/(TP+FP)<br>召回率(recall) = TP/(TP+FN)</p>
<h2 id="10-平方根误差的“意外”"><a href="#10-平方根误差的“意外”" class="headerlink" title="10 平方根误差的“意外”"></a>10 平方根误差的“意外”</h2><p>RMSE计算公式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RMSE=\sqrt&#123; \frac&#123;(y-\hat y)^2&#125;&#123;n&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在实际问题中，如果存在个别偏离程度非常大的离群点时，即使离群点数量非常少，也会让RMSE指标变得很差。<br>思考这个问题有三个方面：第一，如果我们认为这些离群点是噪声点的话，就需要在数据预处理的阶段把这些噪声过滤掉；第二，如果不认为是噪声点，就需要进一步提高模型的预测能力，将离群点产生的机制建模进去；第三，可以找一个更合适的指标来评估该模型，例如平均绝对百分比误差（MAPE）(Mean Absolute Percent Error)</p>
<h2 id="11-什么是-ROC-曲线？"><a href="#11-什么是-ROC-曲线？" class="headerlink" title="11 什么是 ROC 曲线？"></a>11 什么是 ROC 曲线？</h2><p>ROC（Receiver Operating Characteristic Curve）是‘受试者工作特征曲线’。源于军事领域，而后在医学领域应用甚广。<strong><font color="red">ROC曲线横坐标为假阳性率（FPR）；纵坐标为真阳性率（TPR）。</font></strong><br>FPR = FP/N<br>TPR = TP/P</p>
<h2 id="12-如何绘制-ROC-曲线？"><a href="#12-如何绘制-ROC-曲线？" class="headerlink" title="12 如何绘制 ROC 曲线？"></a>12 如何绘制 ROC 曲线？</h2><p>通过不断移动分类器的‘截断点’来生成曲线上的一组关键点。具体而言，通过动态地调整截断点，从最高的得分开始，逐渐调整到最低得分，每一个截断点对应一个FPR和TPR，在ROC图上绘制出每个截断点对应的位置，再连接所有点就得到最终的ROC曲线。<br>还有一种更直观地绘制ROC曲线的方法，首先，根据样本标签统计出正负样本数量，假设正样本数量为P,负样本数量为N;将横轴的刻度间隔设置为1/N，纵轴的刻度间隔设置为1/P；根据模型输出的预测概率对样本进行排序（从高到低）；依次遍历样本，同时从零点开始绘制ROC曲线，每遇到一个正样本就沿纵轴方向绘制一个刻度间隔的曲线，每遇到一个负样本就沿横轴绘制一个刻度间隔的曲线，直至遍历所有样本，最终到（1,1）点。</p>
<h2 id="13-如何计算-AUC"><a href="#13-如何计算-AUC" class="headerlink" title="13 如何计算 AUC?"></a>13 如何计算 AUC?</h2><p>AUC指的是ROC曲线下的面积大小，能够量化地反映基于ROC曲线衡量出的模型性能。计算AUC值只需要沿着ROC横轴做积分就可以了。</p>
<h2 id="14-ROC-曲线相比-P-R-曲线有什么特点"><a href="#14-ROC-曲线相比-P-R-曲线有什么特点" class="headerlink" title="14 ROC 曲线相比 P-R 曲线有什么特点?"></a>14 ROC 曲线相比 P-R 曲线有什么特点?</h2><p>相比P-R曲线，<strong>ROC曲线有一个特点，当正负样本的分布发生变化时，ROC曲线的形状能够基本保持不变，而P-R曲线的形状一般会发生较剧烈的变化。</strong><br>所以，ROC曲线能够尽量降低不同测试集带来的干扰，更加客观地衡量模型本身的性能。但还是因实际问题而异的，如果研究者希望更多地看到模型在特定数据集上的表现，P-R曲线则能更直观地反映其性能。</p>
<h2 id="15-为什么在一些场景中要使用余弦相似度而不是欧氏距离？"><a href="#15-为什么在一些场景中要使用余弦相似度而不是欧氏距离？" class="headerlink" title="15 为什么在一些场景中要使用余弦相似度而不是欧氏距离？"></a>15 为什么在一些场景中要使用余弦相似度而不是欧氏距离？</h2><p>对于两个向量A和B，余弦相似度定义为$cos(A,B)=A<em>B/(||A||</em>||B||)$，即两个向量夹角的余弦，关注的是向量之间的角度关系，并不关心它们的绝对大小，其取值范围是[-1,1]。当一对文本长度差距很大、但内容相近时，如果使用词频或词向量作为特征，它们在特征空间中的欧氏距离通常很大；而如果使用余弦相似度，它们之间的夹角就可能很小，因而相似度高。此外，在文本、图像、视频等领域，研究的对象的特征维度往往很高，余弦相似度在高维情况下仍然保持‘相同时为1，正交时为0，相反时为-1’的性质，而欧氏距离则受维度的影响，范围不固定，并且含义也比较模糊。总体来说，<strong>欧式距离体现数值上的绝对差异，而余弦距离体现方向上的相对差异</strong>。</p>
<h2 id="16-余弦距离是否是一个严格定义的距离？"><a href="#16-余弦距离是否是一个严格定义的距离？" class="headerlink" title="16 余弦距离是否是一个严格定义的距离？"></a>16 余弦距离是否是一个严格定义的距离？</h2><p>距离的定义：在一个集合中，如果每一对元素均可唯一确定一个实数，使得 <strong><font color="red">三条距离公式（正定性，对称性，三角不等式）</font></strong> 成立，则该实数可称为这对元素之间的距离。<br>余弦距离满足正定性和对称性，但是不满足三角不等式，因此并不是严格定义的距离。<br><strong>KL距离(相对熵，Kullback-Leibler DiverGence)，常用于两个分布之间的差异，但不满足对称性和三角不等式。</strong></p>
<h2 id="17-在对模型进行充分的离线评估后，为什么要进行在线-A-B-测试？"><a href="#17-在对模型进行充分的离线评估后，为什么要进行在线-A-B-测试？" class="headerlink" title="17 在对模型进行充分的离线评估后，为什么要进行在线 A/B 测试？"></a>17 在对模型进行充分的离线评估后，为什么要进行在线 A/B 测试？</h2><p>1、离线评估无法完全消除模型过拟合的影响；<br>2、离线评估无法完全还原线上的工程环境，例如线上环境的延迟、数据丢失、标签数据缺失等情况。因此离线评估的结果是理想工程环境下的结果；<br>3、线上系统的某些商业指标在离线评估中无法计算。例如推荐算法带来的用户点击率、留存时长、PV访问量等的变化。</p>
<h2 id="18-如何进行线上A-B测试？"><a href="#18-如何进行线上A-B测试？" class="headerlink" title="18 如何进行线上A/B测试？"></a>18 如何进行线上A/B测试？</h2><p>主要通过用户分桶，即将用户分成实验组和对照组，对实验组的用户用新模型，对对照组的用户用旧模型。在分桶的过程中，要注意样本的独立性和采样方式的无偏性，确保同一用户每次只能分到同一桶中。</p>
<h2 id="19-如何划分实验组和对照组？"><a href="#19-如何划分实验组和对照组？" class="headerlink" title="19 如何划分实验组和对照组？"></a>19 如何划分实验组和对照组？</h2><p>将所有美国用户根据user_id个位数划分为实验组和对照组，分别用模型A和B，才能验证模型A的效果。</p>
<h2 id="20-在模型评估过程中，有哪些主要的验证方法，它们的主要优缺点是什么？"><a href="#20-在模型评估过程中，有哪些主要的验证方法，它们的主要优缺点是什么？" class="headerlink" title="20 在模型评估过程中，有哪些主要的验证方法，它们的主要优缺点是什么？"></a>20 在模型评估过程中，有哪些主要的验证方法，它们的主要优缺点是什么？</h2><ul>
<li>Holdout检验（留出法）<br>将一个原始的样本随机划分成训练集和验证集两部分。其缺点在于在验证集上计算出来的最后评估指标与原始分组有很大关系，具有很大随机性。</li>
<li>交叉检验<ul>
<li>k-fold交叉验证：将全部样本划分为k个大小相同的样本子集，依次遍历这k个子集，每次把当前子集作为验证集，其余所有子集作为训练集，进行模型的训练和评估；最后把k次评估指标的平均值作为最终的评估指标。</li>
<li>留一验证：每次留下一个样本作为验证集，其余所有样本作为训练集。</li>
</ul>
</li>
<li>自助法<br>基于自助采用的检验方法；对于总数为n的样本集合，进行n次有放回的随机抽样，得到大小为n的训练集，将没有被抽出的样本作为验证集，进行模型验证。</li>
</ul>
<h2 id="21-在自助法的采样过程中，对n个样本进行n次自助抽样，当n趋于无穷大时，最终有多少数据从未被选择过？"><a href="#21-在自助法的采样过程中，对n个样本进行n次自助抽样，当n趋于无穷大时，最终有多少数据从未被选择过？" class="headerlink" title="21 在自助法的采样过程中，对n个样本进行n次自助抽样，当n趋于无穷大时，最终有多少数据从未被选择过？"></a>21 在自助法的采样过程中，对n个样本进行n次自助抽样，当n趋于无穷大时，最终有多少数据从未被选择过？</h2><p>1/e = 36.8%</p>
<h2 id="22-超参数有哪些调优方法？"><a href="#22-超参数有哪些调优方法？" class="headerlink" title="22 超参数有哪些调优方法？"></a>22 超参数有哪些调优方法？</h2><ul>
<li>网格搜索</li>
<li>随机搜索</li>
<li>贝叶斯优化算法<br>网格搜索和随机搜索在测试一个新点时，会忽略前一个点的信息；而贝叶斯优化算法则充分利用了之前的信息。贝叶斯优化算法通过对目标函数形状进行学习，找到使目标函数向全局最优值提升的参数。具体来说，贝叶斯优化会选取未知函数的几个已知点，作为先验(prior)，假设他们服从多变量高斯分布，通过最大化收获函数(Acquisition Function）来获得下一个采样点。</li>
</ul>
<h2 id="23-在模型评估过程中，过拟合和欠拟合具体是指什么现象？"><a href="#23-在模型评估过程中，过拟合和欠拟合具体是指什么现象？" class="headerlink" title="23 在模型评估过程中，过拟合和欠拟合具体是指什么现象？"></a>23 在模型评估过程中，过拟合和欠拟合具体是指什么现象？</h2><p>过拟合：在训练集上表现很好，但在测试集和新数据上表现较差。<br>欠拟合：在训练和预测时表现都不好。</p>
<h2 id="24-能否说出几种降低过拟合和欠拟合风险的方法？"><a href="#24-能否说出几种降低过拟合和欠拟合风险的方法？" class="headerlink" title="24 能否说出几种降低过拟合和欠拟合风险的方法？"></a>24 能否说出几种降低过拟合和欠拟合风险的方法？</h2><ul>
<li>降低过拟合：<br>1.从数据入手，获取更多训练数据。<br>2.降低模型复杂度<br>3.正则化方法<br>4.集成学习方法</li>
<li>降低欠拟合：<br>1.添加新特征（FM、GBDT、Deep-crossing）<br>2.增加模型复杂度<br>3.减少正则化系数</li>
</ul>
<h1 id="第3章-经典算法"><a href="#第3章-经典算法" class="headerlink" title="第3章 经典算法"></a>第3章 经典算法</h1><p>参考<a href="https://hellojamest.github.io/tags/algorithms/" target="_blank" rel="noopener">机器学习经典算法</a></p>
<h2 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h2><h3 id="25-在空间上线性可分的两类点，分别向SVM分类的超平面上做投影，这些点在超平面上的投影仍然是线性可分的吗？"><a href="#25-在空间上线性可分的两类点，分别向SVM分类的超平面上做投影，这些点在超平面上的投影仍然是线性可分的吗？" class="headerlink" title="25 在空间上线性可分的两类点，分别向SVM分类的超平面上做投影，这些点在超平面上的投影仍然是线性可分的吗？"></a>25 在空间上线性可分的两类点，分别向SVM分类的超平面上做投影，这些点在超平面上的投影仍然是线性可分的吗？</h3><p>对于任何线性可分的两组点，它们在SVM分类的超平面上的投影都是线性不可分的。</p>
<h3 id="26-是否存在一组参数使SVM训练误差为0？"><a href="#26-是否存在一组参数使SVM训练误差为0？" class="headerlink" title="26 是否存在一组参数使SVM训练误差为0？"></a>26 是否存在一组参数使SVM训练误差为0？</h3><h3 id="27-训练误差为0的SVM分类器一定存在吗？"><a href="#27-训练误差为0的SVM分类器一定存在吗？" class="headerlink" title="27 训练误差为0的SVM分类器一定存在吗？"></a>27 训练误差为0的SVM分类器一定存在吗？</h3><h3 id="28-加入松弛变量的SVM的训练误差可以为0吗？"><a href="#28-加入松弛变量的SVM的训练误差可以为0吗？" class="headerlink" title="28 加入松弛变量的SVM的训练误差可以为0吗？"></a>28 加入松弛变量的SVM的训练误差可以为0吗？</h3><h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><h3 id="29-逻辑回归相比于线性回归，有何异同？"><a href="#29-逻辑回归相比于线性回归，有何异同？" class="headerlink" title="29 逻辑回归相比于线性回归，有何异同？"></a>29 逻辑回归相比于线性回归，有何异同？</h3><p>首先，逻辑回归处理的是分类问题，线性回归处理的是回归问题。二者都使用了极大似然估计来对训练样本进行建模。线性回归使用最小二乘法，实际上是在自变量x与超参数确定，因变量y服从正态分布的假设下，使用极大似然估计的一个化简；而逻辑回归中通过对似然函数$L(θ)$的学习，得到最佳参数。另外，二者在求解超参数的过程中，都可以使用梯度下降的方法。</p>
<h3 id="30-当使用逻辑回归处理多标签的分类问题时，有哪些常见做法，分别应用于哪些场景，它们之间又有怎样的关系？"><a href="#30-当使用逻辑回归处理多标签的分类问题时，有哪些常见做法，分别应用于哪些场景，它们之间又有怎样的关系？" class="headerlink" title="30 当使用逻辑回归处理多标签的分类问题时，有哪些常见做法，分别应用于哪些场景，它们之间又有怎样的关系？"></a>30 当使用逻辑回归处理多标签的分类问题时，有哪些常见做法，分别应用于哪些场景，它们之间又有怎样的关系？</h3><p>取决于具体问题的定义。首先，如果一个样本只对应于一个标签，我们可以假设每个样本属于不同标签的概率服从几何分布，使用多项逻辑回归（softmax regression）来进行分类。<br>当存在样本可能属于多个标签的情况时，我们可以训练k个二分类的逻辑回归分类器。第i个分类器用以区分每个样本是否可以归为第i类。</p>
<h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><h3 id="31-决策树有哪些常用的启发函数？"><a href="#31-决策树有哪些常用的启发函数？" class="headerlink" title="31 决策树有哪些常用的启发函数？"></a>31 决策树有哪些常用的启发函数？</h3><p>参考<a href="https://hellojamest.github.io/2019/04/23/%E5%86%B3%E7%AD%96%E6%A0%91%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">决策树模型</a></p>
<h3 id="32-如何对决策树进行剪枝？"><a href="#32-如何对决策树进行剪枝？" class="headerlink" title="32 如何对决策树进行剪枝？"></a>32 如何对决策树进行剪枝？</h3><ul>
<li><strong>预剪枝</strong><br>预剪枝的核心思想是在树中结点进行扩展之前，先计算当前的划分能否带来模型泛化性能的提升，如果不能就不再继续生长子树。此时若存在不同类别的样本在节点中，按照多数投票原则判断结点类别。何时停止有以下几种方法：<br>1）当树到达一定深度，停止树的生长。<br>2）当到达当前结点的样本数小于某个阈值，停止树的生长<br>3）计算每次分裂对测试集的准确度提升，当小于某个阈值时，不再继续扩展。<br>预剪枝思想直接、算法简单、效率高，适合解决大规模问题。但具有欠拟合的风险。</li>
<li><strong>后剪枝</strong><br>后剪枝的核心思想是让算法生成一颗完全生长的决策树，然后从底层向上计算是否剪枝。相比于预剪枝，后剪枝方法通常可以得到泛化能力更强的决策树，但时间开销会更多。<br>常见的后剪枝方法有错误率降低剪枝、悲观剪枝、代价复杂度剪枝（CCP）、CVP、OPP等方法。CART剪枝方法选择CCP。</li>
</ul>
<h1 id="第4章-降维"><a href="#第4章-降维" class="headerlink" title="第4章 降维"></a>第4章 降维</h1><h2 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h2><h3 id="33-如何定义主成分？从这种定义出发，如何设计目标函数使得降维达到提取主成分的目的？针对这个目标函数，如何对PCA问题进行求解？"><a href="#33-如何定义主成分？从这种定义出发，如何设计目标函数使得降维达到提取主成分的目的？针对这个目标函数，如何对PCA问题进行求解？" class="headerlink" title="33 如何定义主成分？从这种定义出发，如何设计目标函数使得降维达到提取主成分的目的？针对这个目标函数，如何对PCA问题进行求解？"></a>33 如何定义主成分？从这种定义出发，如何设计目标函数使得降维达到提取主成分的目的？针对这个目标函数，如何对PCA问题进行求解？</h3><p>PCA可以找到数据中的主成分，并利用这些主成分表征原始数据，从而达到降维的目的。<br>PCA目标是最大化投影方差，也就是让数据在主轴上投影的方差最大。</p>
<h3 id="34-PCA求解的其实是最佳投影方向，即一条直线，这与数学中线性回归的目标相近，能否从回归的角度定义PCA的目标并相应的求解问题呢？"><a href="#34-PCA求解的其实是最佳投影方向，即一条直线，这与数学中线性回归的目标相近，能否从回归的角度定义PCA的目标并相应的求解问题呢？" class="headerlink" title="34 PCA求解的其实是最佳投影方向，即一条直线，这与数学中线性回归的目标相近，能否从回归的角度定义PCA的目标并相应的求解问题呢？"></a>34 PCA求解的其实是最佳投影方向，即一条直线，这与数学中线性回归的目标相近，能否从回归的角度定义PCA的目标并相应的求解问题呢？</h3><h2 id="线性判别分析"><a href="#线性判别分析" class="headerlink" title="线性判别分析"></a>线性判别分析</h2><h3 id="35-对于具有类别标签的数据，应当如何设计目标函数使得降维的过程中不损失类别信息？在这种目标下，应当如何进行求解？"><a href="#35-对于具有类别标签的数据，应当如何设计目标函数使得降维的过程中不损失类别信息？在这种目标下，应当如何进行求解？" class="headerlink" title="35 对于具有类别标签的数据，应当如何设计目标函数使得降维的过程中不损失类别信息？在这种目标下，应当如何进行求解？"></a>35 对于具有类别标签的数据，应当如何设计目标函数使得降维的过程中不损失类别信息？在这种目标下，应当如何进行求解？</h3><p>LDA的中心思想-最大化类间距离和最小化类内距离。最终转化为一个求矩阵特征向量的问题。</p>
<h3 id="36-LDA和PCA作为经典的降维算法，如何从应用的角度分析其原理的异同？从数学推导的角度，两种降维算法在目标函数上有何区别和联系？"><a href="#36-LDA和PCA作为经典的降维算法，如何从应用的角度分析其原理的异同？从数学推导的角度，两种降维算法在目标函数上有何区别和联系？" class="headerlink" title="36 LDA和PCA作为经典的降维算法，如何从应用的角度分析其原理的异同？从数学推导的角度，两种降维算法在目标函数上有何区别和联系？"></a>36 LDA和PCA作为经典的降维算法，如何从应用的角度分析其原理的异同？从数学推导的角度，两种降维算法在目标函数上有何区别和联系？</h3><p><strong>从目标出发，PCA选择的是投影后数据方差最大的方向，LDA选择的是投影后类内方差小、类间方差大的方向，用到了类别信息。从应用的角度出发，对无监督的一般使用PCA，有监督的则应用LDA</strong></p>
<h1 id="第5章-非监督学习"><a href="#第5章-非监督学习" class="headerlink" title="第5章 非监督学习"></a>第5章 非监督学习</h1><h2 id="K均值聚类"><a href="#K均值聚类" class="headerlink" title="K均值聚类"></a>K均值聚类</h2><h3 id="37-简述K均值算法的具体步骤"><a href="#37-简述K均值算法的具体步骤" class="headerlink" title="37 简述K均值算法的具体步骤"></a>37 简述K均值算法的具体步骤</h3><h3 id="38-K均值算法的优缺点是什么？如何对其进行调优？"><a href="#38-K均值算法的优缺点是什么？如何对其进行调优？" class="headerlink" title="38 K均值算法的优缺点是什么？如何对其进行调优？"></a>38 K均值算法的优缺点是什么？如何对其进行调优？</h3><h3 id="39-针对k均值算法的缺点，有哪些改进的模型？"><a href="#39-针对k均值算法的缺点，有哪些改进的模型？" class="headerlink" title="39 针对k均值算法的缺点，有哪些改进的模型？"></a>39 针对k均值算法的缺点，有哪些改进的模型？</h3><ul>
<li>二分 (bisecting) k-means算法<br>二分K-means算法首先将所有点作为一个簇，然后将簇一分为二。之后选择其中一个簇继续进行划分，选择哪一个簇取决于对其进行划分是否能够最大程度的降低SSE的值。上述划分过程不断重复，直至划分的簇的数目达到用户指定的值为止。<br>二分k-means算法对初始质心的选择不太敏感，因为初始时只选择一个质心。</li>
<li>K-means++算法<br>K均值算法最开始随机选取数据集中K个点作为簇类中心，而K-means++算法在选择n个初始聚类中心之后，选择第n+1个聚类中心时，距离当前n个聚类中心越远的点会有更高的概率被选为第n+1个聚类中心。</li>
<li>ISODATA算法<br>当K大小不确定时，可以使用ISODATA算法（迭代自组织数据分析法）。其思想是当属于某个类别的样本数过少时，把该类别去除；当属于某个类别的样本数过多、分散程度较大时，把该类别分为两个子类别。它在K均值算法的基础上增加了两个操作，一是分裂操作，增加聚类中心；二是合并操作，对于减少聚类中心。其缺点是需要指定的参数较多：（1）预期的聚类中心数目；（2）每个类所要求的最少样本数目N；（3）最大方差Sigma；（4）两个聚类中心之间所允许最小距离D</li>
</ul>
<h3 id="40-证明K均值算法的收敛性"><a href="#40-证明K均值算法的收敛性" class="headerlink" title="40 证明K均值算法的收敛性"></a>40 证明K均值算法的收敛性</h3><p>K均值算法实际上是一种最大期望算法（EM）。在E步骤中，等同于K均值算法中对于每一个点x找到当前最近的簇z。<br>M步骤，等同于找到最优的中心点。</p>
<h2 id="高斯混合模型"><a href="#高斯混合模型" class="headerlink" title="高斯混合模型"></a>高斯混合模型</h2><h3 id="41-高斯混合模型的核心思想是什么？它是如何迭代计算的？"><a href="#41-高斯混合模型的核心思想是什么？它是如何迭代计算的？" class="headerlink" title="41 高斯混合模型的核心思想是什么？它是如何迭代计算的？"></a>41 高斯混合模型的核心思想是什么？它是如何迭代计算的？</h3><p><strong>高斯混合模型（GMM）的核心思想是，假设数据可以看作从多个高斯分布中生成出来的。在该假设下，我们需要寻找每个单独的分模型的均值、方差以及权重。</strong> 采用EM算法框架来求解该优化问题。EM算法是在最大化目标函数时，先固定一个变量使整体函数变成凸优化函数，求导得到最值，然后利用最优参数更新被固定的变量，进入下一循环。具体到高斯混合模型的求解，EM算法的迭代过程如下：<br>首先，初始随机选择各参数的值。然后，重复下面两步，直到收敛：<br>（1）E步骤，根据当前参数，计算每个点由分模型生成的概率<br>（2）M步骤，使用E步骤估计出的概率，来改进每个分模型的均值，方差和权重。<br>高斯混合模型与K均值算法相同点：<br>1.都是可用于聚类的算法<br>2.都需要指定K值<br>3.都是使用EM算法来求解<br>4.都往往只能收敛于局部最优<br>不同点：<br>1.混合高斯模型可以给出一个样本属于某类的概率是多少<br>2.不仅仅可以用于聚类，还可以用于概率密度的估计<br>3.可以用于生成新的样本点</p>
<h2 id="自组织映射神经网络"><a href="#自组织映射神经网络" class="headerlink" title="自组织映射神经网络"></a>自组织映射神经网络</h2><h3 id="42-自组织映射神经网络是如何工作的？它与K均值算法有何区别？"><a href="#42-自组织映射神经网络是如何工作的？它与K均值算法有何区别？" class="headerlink" title="42 自组织映射神经网络是如何工作的？它与K均值算法有何区别？"></a>42 自组织映射神经网络是如何工作的？它与K均值算法有何区别？</h3><p><strong>自组织映射神经网络（SOM）本质上是一个两层的神经网络</strong>，包含输入层与输出层</p>
<h3 id="43-怎样设计自组织映射神经网络并设定网络训练参数？"><a href="#43-怎样设计自组织映射神经网络并设定网络训练参数？" class="headerlink" title="43 怎样设计自组织映射神经网络并设定网络训练参数？"></a>43 怎样设计自组织映射神经网络并设定网络训练参数？</h3><ul>
<li>输出层神经元的数量</li>
<li>设计输出层节点的排列</li>
<li>初始化权值</li>
<li>设计拓扑领域</li>
<li>设计学习率<h3 id="44-以聚类算法为例，假设没有外部标签数据，如何评估两个聚类算法的优劣？"><a href="#44-以聚类算法为例，假设没有外部标签数据，如何评估两个聚类算法的优劣？" class="headerlink" title="44 以聚类算法为例，假设没有外部标签数据，如何评估两个聚类算法的优劣？"></a>44 以聚类算法为例，假设没有外部标签数据，如何评估两个聚类算法的优劣？</h3>估计在数据集上进行聚类的可行性，以及聚类方法产生结果的质量。</li>
<li>估计聚类趋势<br>检测数据分布中是否存在非随机的簇结构。可以观察聚类误差是否随聚类类别数量的增加而单调变化，如果数据是随机分布的，那么其变化幅度应该较不显著，并且也找不到一个合适的K对应数据的真实簇数。另外，也可以应用霍普金斯统计量来判断数据在空间上的随机性。</li>
<li>判断数据簇类<br>例如手肘法和Gap Statistics方法</li>
<li>测定聚类质量<br>考察簇的分离情况和簇的紧凑情况来评估聚类的效果。测量指标有：<ul>
<li>轮廓系数</li>
<li>均方根标准偏差</li>
<li>R方</li>
<li>改进的HubertT统计</li>
</ul>
</li>
</ul>
<h1 id="第6章-概率图模型"><a href="#第6章-概率图模型" class="headerlink" title="第6章 概率图模型"></a>第6章 概率图模型</h1><h2 id="45-贝叶斯网络的联合概率分布"><a href="#45-贝叶斯网络的联合概率分布" class="headerlink" title="45 贝叶斯网络的联合概率分布"></a>45 贝叶斯网络的联合概率分布</h2><h2 id="46-马尔科夫网络的联合概率分布"><a href="#46-马尔科夫网络的联合概率分布" class="headerlink" title="46 马尔科夫网络的联合概率分布"></a>46 马尔科夫网络的联合概率分布</h2><h2 id="47-解释贝叶斯模型的原理，并给出概率图模型表示"><a href="#47-解释贝叶斯模型的原理，并给出概率图模型表示" class="headerlink" title="47 解释贝叶斯模型的原理，并给出概率图模型表示"></a>47 解释贝叶斯模型的原理，并给出概率图模型表示</h2><h2 id="48-解释最大熵模型的原理，并给出概率图模型表示"><a href="#48-解释最大熵模型的原理，并给出概率图模型表示" class="headerlink" title="48 解释最大熵模型的原理，并给出概率图模型表示"></a>48 解释最大熵模型的原理，并给出概率图模型表示</h2><h2 id="49-常见的概率图模型中，哪些是生成式模型，哪些是判别式模型？"><a href="#49-常见的概率图模型中，哪些是生成式模型，哪些是判别式模型？" class="headerlink" title="49 常见的概率图模型中，哪些是生成式模型，哪些是判别式模型？"></a>49 常见的概率图模型中，哪些是生成式模型，哪些是判别式模型？</h2><p><strong>生成式模型是由数据学习联合概率分布P(X,Y)，然后求出条件概率分布P(Y|X)作为预测的模型</strong><br>典型的生成式模型有：朴素贝叶斯、贝叶斯网络、pLSA、LDA、隐马尔科夫模型<br><strong>判别式模型是由数据直接学习决策函数f(X)或者条件概率分布P(Y|X)作为预测的模型</strong><br>典型的判别式模型有：最大熵模型、条件随机场</p>
<h2 id="50-如何对中文分词问题用隐马尔科夫模型进行建模和训练？"><a href="#50-如何对中文分词问题用隐马尔科夫模型进行建模和训练？" class="headerlink" title="50 如何对中文分词问题用隐马尔科夫模型进行建模和训练？"></a>50 如何对中文分词问题用隐马尔科夫模型进行建模和训练？</h2><p>隐马尔科夫模型通常用来解决序列标注问题，因此也可以将分词问题转化为一个序列标注问题来进行建模。例如，可以对中文句子中每个字做以下标注，B表示一个词开头的第一个字，E表示一个词结尾的最后一个字，M表示一个词中间的字，S表示一个单字词，则隐状态的取值空间为{B,E,M,S}。同时对隐状态的转移概率可以给出一些先验知识，B和M后面只能是M或者E，S和E后面只能是B或者S。而每个字就是模型中的观测状态，取值空间为预料中的所有中文字。完成建模之后，使用语料进行训练可以分为有监督训练和无监督训练。</p>
<h2 id="51-最大熵马尔可夫模型（MEMM）为什么会产生标注偏置问题？如何解决？"><a href="#51-最大熵马尔可夫模型（MEMM）为什么会产生标注偏置问题？如何解决？" class="headerlink" title="51 最大熵马尔可夫模型（MEMM）为什么会产生标注偏置问题？如何解决？"></a>51 最大熵马尔可夫模型（MEMM）为什么会产生标注偏置问题？如何解决？</h2><p>由于局部归一化的影响，隐状态会倾向于转移到后续状态可能更少的状态上，以提高整体的后验概率。这就是标注偏置问题。<br>可以使用条件随机场（CRF），进行全局归一化。</p>
<h2 id="52-常见的主题模型有哪些？试介绍其原理。"><a href="#52-常见的主题模型有哪些？试介绍其原理。" class="headerlink" title="52 常见的主题模型有哪些？试介绍其原理。"></a>52 常见的主题模型有哪些？试介绍其原理。</h2><p>基于词袋模型或N-gram模型的文本表示模型有一个明显的缺陷，无法识别出两个不同的词或词组具有相同的主题。因此，可以通过主题模型将具有相同主题的词或词组映射到同一维度上。<br>主题模型是用来在大量文档中发现潜在主题的一种统计模型。</p>
<ul>
<li>pLSA</li>
<li>LDA</li>
</ul>
<h2 id="53-如何确定LDA模型中的主题个数？"><a href="#53-如何确定LDA模型中的主题个数？" class="headerlink" title="53 如何确定LDA模型中的主题个数？"></a>53 如何确定LDA模型中的主题个数？</h2><p>常用评估指标为困惑度（perplexity），在文档集合D上，模型的困惑度被定义为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perplexity(D)=\exp&#123;\&#123; -\frac&#123;\sum_&#123;d=1&#125;^M \log p(w_d)&#125;&#123;\sum_&#123;d=1&#125;^M N_d&#125; \&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，M为文档的总数，$w_d$为文档d中单词所组成的词袋向量，$p(w_d)$是模型所预测的文档d的生成概率，$N_d$是文档d中单词的总数。<br>在实践中，一般选择合理范围内困惑度的下降明显变慢（拐点）的时候。</p>
<h2 id="54-如何用主题模型来解决推荐系统中的冷启动问题？"><a href="#54-如何用主题模型来解决推荐系统中的冷启动问题？" class="headerlink" title="54 如何用主题模型来解决推荐系统中的冷启动问题？"></a>54 如何用主题模型来解决推荐系统中的冷启动问题？</h2><p>推荐系统中的冷启动问题，是指没有大量用户数据的情况下如何给用户进行个性化推荐，目的是最优化点击率、转化率或用户体验。冷启动问题一般分为用户冷启动、物品冷启动和系统冷启动三大类。<br>解决冷启动问题的方法一般是基于内容的推荐。对于用户冷启动，可以根据用户的注册信息，得到用户的兴趣主题，找到与该用户兴趣相同的其他用户，通过他们的历史行为来预测用户的兴趣。对于物品冷启动，可以根据电影的导演、演员等信息推测电影所属于的主题，如何基于主题向量找到相似的电影，并将新电影推荐给以往喜欢看这些相似电影的用户。<br>解决系统冷启动，首先可以得到每个用户和电影对应的主题向量。当系统没有任何数据时，我们需要一些先验知识来指定，并且由于主题的数目通常比较小，随着系统的上限，收集到少量的数据之后我们就可以对主题之间的偏好程度得到一个比较准确的估计。</p>
<h1 id="第7章-优化算法"><a href="#第7章-优化算法" class="headerlink" title="第7章 优化算法"></a>第7章 优化算法</h1><h2 id="55-有监督学习设计的损失函数有哪些？请列举并简述它们的特点？"><a href="#55-有监督学习设计的损失函数有哪些？请列举并简述它们的特点？" class="headerlink" title="55 有监督学习设计的损失函数有哪些？请列举并简述它们的特点？"></a>55 有监督学习设计的损失函数有哪些？请列举并简述它们的特点？</h2><ul>
<li>损失函数（Loss Function）：是定义在单个样本上的，是指一个样本的误差。</li>
<li>代价函数（Cost Function）：是定义在整个训练集上的，是所有样本误差的平均，也就是所有损失函数值的平均。</li>
<li>目标函数（Object Function）：是指最终需要优化的函数，一般来说是经验风险+结构风险，也就是（代价函数+正则化项）。</li>
</ul>
<p>常用的损失函数：</p>
<ul>
<li>0-1损失函数（0-1 loss function）<br>$$<br>L(y,f(x))=<br>\begin{cases}<br>1,y \neq f(x) \\<br>0,y=f(x)<br>\end{cases}<br>$$</li>
<li>对数损失函数（logarithmic loss function）<br>$$<br>L(y,f(x))=-\log p(y|x)<br>$$</li>
<li>指数损失函数<br>$$<br>L(y,f(x))=exp(-yf(x))<br>$$</li>
<li>Hinge(合页)损失函数<br>$$<br>L(w,b)=max{0,1-yf(x)}<br>$$<br>其中y=+1或y=-1，f(x)=wx+b，当为SVM的线性核时。</li>
<li>平方损失函数（quadratic loss function）<br>$$<br>L(y,f(x))=(y-f(x))^2<br>$$</li>
<li>绝对值损失函数（absolute loss function）<br>$$<br>L(y,f(x))=|y-f(x)|<br>$$</li>
</ul>
<p>常用的代价函数：<br>均方误差（Mean Squared Error）<br>$$<br>MSE=\frac{1}{m}\sum_{i=1}^m (y_i-\hat y_i)^2<br>$$<br>平均绝对误差（Mean Absolute Error）<br>$$<br>MAE=\frac{1}{m}\sum_{i=1}^m |y_i-\hat y_i|<br>$$<br>均方根误差<br>$$<br>RMSE=\sqrt{\frac{1}{m}\sum_{i=1}^m (y_i-\hat y_i)^2}<br>$$<br>交叉熵代价函数（Cross Entry）<br>$$<br>L(w,b)=-\frac{1}{N}\sum_{i=1}^m (y_i \log {f(x_i)}+(1-y_i) \log {(1-f(x_i)}))<br>$$</p>
<h2 id="56-机器学习中的优化问题，哪些是凸优化问题，哪些是非凸优化问题？"><a href="#56-机器学习中的优化问题，哪些是凸优化问题，哪些是非凸优化问题？" class="headerlink" title="56 机器学习中的优化问题，哪些是凸优化问题，哪些是非凸优化问题？"></a>56 机器学习中的优化问题，哪些是凸优化问题，哪些是非凸优化问题？</h2><p>凸优化问题包括支持向量机、线性回归、逻辑回归等线性模型，非凸优化问题包括低秩模型（如矩阵分解）、深度神经网络模型等。</p>
<h2 id="57-无约束优化问题的优化方法有哪些？"><a href="#57-无约束优化问题的优化方法有哪些？" class="headerlink" title="57 无约束优化问题的优化方法有哪些？"></a>57 无约束优化问题的优化方法有哪些？</h2><p>经典的优化算法可以分为直接法和迭代法两大类。<br>直接法，就是能够直接给出优化问题最优解的方法。它要求目标函数满足两个条件，L()是凸函数，且有闭式解。以线性回归为例<br>线性回归中，其代价函数为：<br>$$<br>J(\theta)=\frac{1}{2} \sum_{i=1}^m (h_\theta(x^{(i)})-y^{(i)})^2<br>$$<br>使用矩阵对损失函数求导，有：<br>$$<br>\begin{aligned}<br>L(w) = &amp; \frac{1}{2} (XW-y)^T(XW-y) \\<br>=&amp; \frac{1}{2} (W^TX^TXW-W^TX^Ty-y^TXW+y^Ty) \\<br>=&amp; \frac{1}{2} (W^TX^TXW-2W^TX^Ty+y^Ty)<br>\end{aligned}<br>$$<br>则，<br>$$<br>\frac{\partial L(w)}{\partial w}=\frac{1}{2}[W^TX^TX-2X^Ty]=0<br>$$<br>$$<br>X^TXW=X^Ty<br>$$<br>得<br>$$<br>W=(X^TX)^{-1}X^Ty<br>$$<br>迭代法又分为一阶法和二阶法两类。一阶法对函数做一阶泰勒展开；又称梯度下降法；<br>二阶法做二阶泰勒展开；又称牛顿法。二阶法收敛速度快，但在高维情况下，海森矩阵求逆的计算复杂度很大，而且当目标为非凸时，可能会收敛到鞍点。</p>
<h2 id="58-如何验证求目标函数梯度功能的正确性？"><a href="#58-如何验证求目标函数梯度功能的正确性？" class="headerlink" title="58 如何验证求目标函数梯度功能的正确性？"></a>58 如何验证求目标函数梯度功能的正确性？</h2><p>可以做梯度验证。</p>
<h2 id="59-当训练数据量特别大时，经典的梯度下降法存在什么问题，需要做如何改进？"><a href="#59-当训练数据量特别大时，经典的梯度下降法存在什么问题，需要做如何改进？" class="headerlink" title="59 当训练数据量特别大时，经典的梯度下降法存在什么问题，需要做如何改进？"></a>59 当训练数据量特别大时，经典的梯度下降法存在什么问题，需要做如何改进？</h2><p>经典的梯度下降法在每次对模型参数进行更新时，需要遍历所有的训练数据。当M很大时，这需要很大的计算量，耗费很长的计算时间。可采用随机梯度下降法或者小批量梯度下降法。随机梯度下降法是使用单个数据对模型参数进行更新，大大加快了收敛速率，也适用于在线更新的场景。小批量梯度下降法是同时使若干个训练数据。有三点需要注意的地方：<br>1）如何选取参数m？一般通过调参。取m为2的幂次，充分利用矩阵运算操作。<br>2）如何挑选m个训练数据？需要先对所有的数据进行随机排序<br>3）如何选取学习速率a？为了加快收敛速率，同时提高求解精度，通常会采用衰减学习速率的方案：一开始算法采用较大的学习速率，当误差曲线进入平台期后，减小学习速率做更精细的调整。</p>
<h2 id="60-随机梯度下降法为什么会失效？"><a href="#60-随机梯度下降法为什么会失效？" class="headerlink" title="60 随机梯度下降法为什么会失效？"></a>60 随机梯度下降法为什么会失效？</h2><p>因为随机梯度下降每步仅仅随机采样一个（或少量）样本来估计当前梯度，计算速度快，内存开销小。但由于每步接受的信息量有限，随机梯度下降达对梯度的估计常常出现偏差，造成目标函数曲线收敛得很不稳定，伴有剧烈波动，有时甚至出现不收敛的情况。对随机梯度下降来说，如何徘徊在山谷和鞍点。其中，在山谷中，准确的梯度方向是沿着山道向下，稍有偏离就会撞向山壁，而粗糙的梯度估计使得它在两山壁间来回反弹震荡，不能沿山道方向迅速下降，导致收敛不稳定和收敛速度慢。在鞍点处，随机梯度下降法会进入一片平坦的地方（plateau），梯度几乎为零，随机梯度下降法无法准确察觉出梯度的微小变化，造成停滞。</p>
<h2 id="61-如何改进？"><a href="#61-如何改进？" class="headerlink" title="61 如何改进？"></a>61 如何改进？</h2><ul>
<li>动量（Momentun）法</li>
<li>AdaGrad法</li>
<li>Adam法</li>
</ul>
<h2 id="62-L1正则化使得模型参数具有稀疏性的原理是什么？"><a href="#62-L1正则化使得模型参数具有稀疏性的原理是什么？" class="headerlink" title="62 L1正则化使得模型参数具有稀疏性的原理是什么？"></a>62 L1正则化使得模型参数具有稀疏性的原理是什么？</h2><p>事实上，带正则项与带约束条件是等价的。为了约束w的可能取值空间从而防止过拟合，我们为最优化问题加上一个约束，就是w的L2范数的平方不能大于m：<br>$$<br>\begin{cases}<br>\min \sum_{i=1}^N {(y_i-w^Tx_i)^2} \\<br>s.t. ||w||^2 \leq m<br>\end{cases}<br>$$<br>L2正则化相当于为参数定义了一个圆形的解空间（因为必须保证L2范数不能大于m），而L1正则化相当于为参数定义了一个菱形的解空间。<br>我们令黄色部分是L2和L1正则约束后的解空间，等高线是凸优化问题中目标函数的等高线，可知L1正则化多边形的解空间更容易在尖角处与等高线碰撞出稀疏解。</p>
<h1 id="第8章-采样"><a href="#第8章-采样" class="headerlink" title="第8章 采样"></a>第8章 采样</h1><h2 id="63-举例说明采样在机器学习中的应用。"><a href="#63-举例说明采样在机器学习中的应用。" class="headerlink" title="63 举例说明采样在机器学习中的应用。"></a>63 举例说明采样在机器学习中的应用。</h2><p>采样本质是对随机现象的模拟，根据给定的概率分布，来模型产生一个对应的随机事件。</p>
<ul>
<li>可以通过采样来用较少量的样本点来近似总体分布，并刻画总体分布中的不确定性。可以简化问题。</li>
<li>对当前数据进行重采样，可以充分利用已有的数据集，挖掘更多的信息。例如，处理样本不均衡问题。</li>
<li>利用采样方法进行随机模拟，从而对复杂模型进行近似求解和推理。例如，在LDA（隐狄利克雷模型）中，采用吉布斯采样对隐变量的分布进行采样。</li>
</ul>
<h2 id="64-如何编程实现均匀分布随机数生成器？"><a href="#64-如何编程实现均匀分布随机数生成器？" class="headerlink" title="64 如何编程实现均匀分布随机数生成器？"></a>64 如何编程实现均匀分布随机数生成器？</h2><p>采用线性同余法，生成离散均匀分布伪随机数，计算公式为：<br>$$<br>x_{t+1} = a*x_t+c( mod \ m)<br>$$<br>可得到【0,m-1】上的随机整数。除以m可得0-1区间上的连续随机数。</p>
<h2 id="65-通用采样方法主要思想以及具体操作步骤"><a href="#65-通用采样方法主要思想以及具体操作步骤" class="headerlink" title="65 通用采样方法主要思想以及具体操作步骤"></a>65 通用采样方法主要思想以及具体操作步骤</h2><ul>
<li>逆变换采样。其过程为：<br>1）从均匀分布U(0,1)产生一个随机数；<br>2）计算$x_i=\Phi ^ {-1}(u_i)$，其中$\Phi ^ {-1}$是累计分布函数的逆函数。</li>
<li>拒绝采样<br>对于目标分布p(x)，选取一个容易采样的参考分布q(x)，使得对于任意x都有p(x)&lt;=Mq(x)，则过程为:<br>1）从参考分布q(x)中随机抽取一个样本x<br>2）从均匀分布U(0,1)产生一个随机数u<br>3）如果$u_i&lt;\frac{p(x_i)}{Mq(x_i)}$，则接受样本x；否则拒绝，重新进行步骤1-3，直到新产生的样本被接受。</li>
</ul>
<h2 id="66-如何对高斯分布进行采样？"><a href="#66-如何对高斯分布进行采样？" class="headerlink" title="66 如何对高斯分布进行采样？"></a>66 如何对高斯分布进行采样？</h2><ul>
<li>逆变换采样</li>
<li>拒绝采样</li>
</ul>
<h2 id="67-简述MCMC采样法的主要思想"><a href="#67-简述MCMC采样法的主要思想" class="headerlink" title="67 简述MCMC采样法的主要思想"></a>67 简述MCMC采样法的主要思想</h2><p>MCMC采样的基本思想是：针对待采样的目标分布，构造一个马尔可夫链，使得该马尔科夫链的平稳分布就是目标分布；然后，从任何一个初始状态出发，沿着马尔科夫链进行状态转移，最终得到的状态转移序列会收敛到目标分布，由此可以得到目标分布的一系列样本。</p>
<h2 id="68-几种常见的MCMC采样法"><a href="#68-几种常见的MCMC采样法" class="headerlink" title="68 几种常见的MCMC采样法"></a>68 几种常见的MCMC采样法</h2><ul>
<li>Metropolis-Hastings采样法</li>
<li>吉布斯采样法<br>其核心思想是每次只对样本的一个维度进行采样和更新</li>
</ul>
<h2 id="69-MCMC采样法如何得到相互独立的样本"><a href="#69-MCMC采样法如何得到相互独立的样本" class="headerlink" title="69 MCMC采样法如何得到相互独立的样本"></a>69 MCMC采样法如何得到相互独立的样本</h2><p>可以运行多条马尔科夫链，这样不同链上的样本是独立的；<br>或者在同一天马尔科夫链上每隔若干个样本才取一个，这样就是近似独立的。</p>
<h2 id="70-如何对贝叶斯网络进行采样？如果只需要考虑一部分变量的边缘分布，如何采样？如果网络中含有观测变量，又该如何采样？"><a href="#70-如何对贝叶斯网络进行采样？如果只需要考虑一部分变量的边缘分布，如何采样？如果网络中含有观测变量，又该如何采样？" class="headerlink" title="70 如何对贝叶斯网络进行采样？如果只需要考虑一部分变量的边缘分布，如何采样？如果网络中含有观测变量，又该如何采样？"></a>70 如何对贝叶斯网络进行采样？如果只需要考虑一部分变量的边缘分布，如何采样？如果网络中含有观测变量，又该如何采样？</h2><h2 id="71-对于二分类问题，当训练集中负样本非常不均衡时，如何处理数据以更好地训练分类模型？"><a href="#71-对于二分类问题，当训练集中负样本非常不均衡时，如何处理数据以更好地训练分类模型？" class="headerlink" title="71 对于二分类问题，当训练集中负样本非常不均衡时，如何处理数据以更好地训练分类模型？"></a>71 对于二分类问题，当训练集中负样本非常不均衡时，如何处理数据以更好地训练分类模型？</h2><ul>
<li>基于数据的方法<br>对数据进行重采样，使原本不平衡的样本变得均衡。例如，随机采样（过采样和欠采样）。随机过采样是从少数类样本集中随机重复抽取样本（有放回）得到更多样本；随机欠采样则相反，从多数类样本集中随机选取较少的样本（有放回和无放回）。<br>但是，直接的过采样扩大了数据规模，增加了模型训练的复杂度，同时容易造成过拟合；欠采样会丢弃一些样本，可能会损失部分有用信息，造成模型只学到了整体模式的一部分。为了解决以上问题，可以使用SMOTE算法生成新的样本。SMOTE算法对少数类集中每个样本x，从它在少数类的K近邻中随机选一个样本y，然后在x，y连续上随机选取一点作为新合成的样本。另外有，Borderline-SMOTE、ADASYN等改进算法。此外，还可以采用一些数据处理方法（如基于Tomek Links）来进一步降低合成样本带来的类间重叠，更好地训练分类器。<br>对于欠采样，可以使用Informed Undersampling来解决数据丢失问题，如：Easy Ensemble算法/Balance Cascade算法/NearMiss/One-sided Selection 算法。</li>
<li>基于算法的方法<br>可以通过改变模型训练时的目标函数（如代价敏感学习中不同类别有不同的权重）来矫正不平衡性；当样本数目极其不平衡时，也可以将问题转化为单类学习（one-class learning）、异常检测（anomaly detecion）。</li>
</ul>
<h1 id="第9章-前向神经网络"><a href="#第9章-前向神经网络" class="headerlink" title="第9章 前向神经网络"></a>第9章 前向神经网络</h1><h2 id="72-写出常用激活函数以及导数"><a href="#72-写出常用激活函数以及导数" class="headerlink" title="72 写出常用激活函数以及导数"></a>72 写出常用激活函数以及导数</h2><ul>
<li>sigmid<br>$$<br>f(z)=\frac{1}{1+\exp(-z)}<br>$$<br>对应的导函数为：<br>$$<br>f’(z)=f(z)(1-f(z))<br>$$</li>
<li>tanh<br>$$<br>f(z)=tanh(z)=\frac{e^{z}-e^{-z} }{e^{z}+e^{-z} }<br>$$<br>对应的导函数为：<br>$$<br>f’(z)=1-(f(z))^2<br>$$</li>
<li>relu<br>$$<br>f(z)=\max(0,z)<br>$$<br>对应的导函数为：<br>$$<br>f’(z)=<br>\begin{cases}<br>1,z&gt;0 \\<br>0,z \leq 0<br>\end{cases}<br>$$</li>
</ul>
<h2 id="73-为什么sigmoid和tanh激活函数会导致梯度消失的现象？"><a href="#73-为什么sigmoid和tanh激活函数会导致梯度消失的现象？" class="headerlink" title="73 为什么sigmoid和tanh激活函数会导致梯度消失的现象？"></a>73 为什么sigmoid和tanh激活函数会导致梯度消失的现象？</h2><p>sigmoid激活曲线可以看出：当z很大时，f(z)趋近于1；当z很小时，f(z)趋近于0。其导数在z很大或很小都会趋近于0，造成梯度消失的现象。<br>sigmoid激活曲线可以看出：当z很大时，f(z)趋近于1；当z很小时，f(z)趋近于-1。其导数在z很大或很小都会趋近于0，造成梯度消失的现象。实际上，tanh激活函数相当于sigmoid的平移。</p>
<h2 id="74-Relu系列的激活函数相对于Sigmoid和Tanh激活函数的优点是什么？它们有什么局限性以及如何改进？"><a href="#74-Relu系列的激活函数相对于Sigmoid和Tanh激活函数的优点是什么？它们有什么局限性以及如何改进？" class="headerlink" title="74 Relu系列的激活函数相对于Sigmoid和Tanh激活函数的优点是什么？它们有什么局限性以及如何改进？"></a>74 Relu系列的激活函数相对于Sigmoid和Tanh激活函数的优点是什么？它们有什么局限性以及如何改进？</h2><p>优点：<br>从计算上，sigmoid和tanh激活函数均需要计算指数，复杂度高，而Relu只需要一个阈值就可以得到激活值。<br>relu的非饱和性可以有效地解决梯度消失的问题，提供相对宽的激活边界。<br>relu的单侧拟制提供了网络的稀疏表达能力。<br>局限性：<br>其训练过程中会导致神经元死亡的问题。这是由于relu函数导致负梯度在经过该relu单元时被置为0，且在之后也不被任何数据激活，导致梯度永远为0。在实际训练中，如果学习率设置过大，会导致一定比率的神经元不可逆死亡，进而参数梯度无法更新，整个训练过程失败。<br>所以，有relu的变种Leaky Relu，既实现了单侧拟制，又保留了部分负梯度信息以致不完全丢失，但另一方面，a值的选择增加了问题难度，又有参数化的PReLU，LReLU，Random ReLU等。</p>
<h2 id="75-relu为什么不能根治梯度消失？"><a href="#75-relu为什么不能根治梯度消失？" class="headerlink" title="75 relu为什么不能根治梯度消失？"></a>75 relu为什么不能根治梯度消失？</h2><p>梯度反向传播不是只和激活函数有关</p>
<h2 id="76-写出多层感知机的平方误差和交叉熵损失函数。推导各层参数更新的梯度计算公式。"><a href="#76-写出多层感知机的平方误差和交叉熵损失函数。推导各层参数更新的梯度计算公式。" class="headerlink" title="76 写出多层感知机的平方误差和交叉熵损失函数。推导各层参数更新的梯度计算公式。"></a>76 写出多层感知机的平方误差和交叉熵损失函数。推导各层参数更新的梯度计算公式。</h2><p>多层感知机中，输入信号通过各个网络层的隐节点产生输出的过程称为前向传播。我们定义低(l)层的输入为$x^{(l)}$,输出为$a^{(l)}$；在每一层中$z^{(l)}=w^{(l)}x^{(l)}+b^{(l)}$,，然后利用激活函数$f$得到$a^{(l)}=f(z^{(l)})$；$a^{(l)}$直接作为下一层输入，即$x^{(l+1)}$。设$z^{(l)}$和$a^{(l)}$为$s_l$的向量，则$W_l$为$s_l*s_{l+1}$维的矩阵。<br>平方误差的整体代价函数为：<br>$$<br>J(W,b)=[\frac{1}{m}\sum_{i=1}^m J(W,b;x^{(i)},y^{(i)})]+\frac{\lambda}{2} \sum_{l=1}^N \sum_{i=1}^{S_{l-1}} \sum_{j=1}^{S_l}(W_{ji}^{(l)})^2 \\<br>=[\frac{1}{m}\sum_{i=1}^m \frac{1}{2}||y^{(i)}-o^{(i)}||^2]+\frac{\lambda}{2} \sum_{l=1}^N \sum_{i=1}^{S_{l-1}} \sum_{j=1}^{S_l}(W_{ji}^{(l)})^2<br>$$<br>在二分类中，交叉熵的整体代价函数为：<br>$$<br>J(W,b)=[\frac{1}{m}\sum_{i=1}^m J(W,b;x^{(i)},y^{(i)})]+\frac{\lambda}{2} \sum_{l=1}^N \sum_{i=1}^{S_{l-1}} \sum_{j=1}^{S_l}(W_{ji}^{(l)})^2 \\<br>=-[\frac{1}{m}\sum_{i=1}^m {y^{(i)}\ln o^{(i)} + (1-y^{(i)}) \ln (1-o^{(i)}})]+\frac{\lambda}{2} \sum_{l=1}^N \sum_{i=1}^{S_{l-1}} \sum_{j=1}^{S_l}(W_{ji}^{(l)})^2<br>$$<br>在多分类下，<br>$$<br>J(W,b)=-[\frac{1}{m}\sum_{i=1}^m \sum_{k=1}^n y_k^{(i)} \ln o_k^{(i)}]+\frac{\lambda}{2} \sum_{l=1}^N \sum_{i=1}^{S_{l-1}} \sum_{j=1}^{S_l}(W_{ji}^{(l)})^2<br>$$<br>梯度下降法中每次迭代对参数$W$（网络连接权重）和$b$(偏置）进行更新：<br>$$<br>W_{ji}^{(l)}=W_{ji}^{(l)}-\alpha \frac{\partial}{\partial W_{ji}^{(l)}}J(w,b) \\<br>b_{j}^{(l)}=b_{j}^{(l)}-\alpha \frac{\partial}{\partial b_{j}^{(l)}}J(w,b)<br>$$<br>其中，$\alpha$为学习率。<br>其中：<br>$$<br>\frac{\partial}{\partial W_{ji}^{(l)}}J(w,b) = \frac{\partial J(w,b)}{\partial z_{j}^{(l)}}  \frac{\partial z_{j}^{(l)}}{\partial W_{ji}^{(l)}}<br>$$<br>先计算损失函数对隐含层的偏导<br>$$<br>\frac{\partial J(w,b)}{\partial z_{j}^{(l)}}=\sum_{k=1}^{S_{l+1}} (\frac{\partial J(w,b)}{\partial z_{k}^{(l+1)}}  \frac{\partial z_{k}^{(l+1)}}{\partial z_{j}^{(l)}})<br>$$<br>$$<br>\frac{\partial z_{k}^{(l+1)}}{\partial z_{j}^{(l)}} = \frac{\partial (\sum_{j=1}^{S_l}(W_{kj}^{(l+1)} x_j^{(l+1)}+b_k^{(l+1)}))}{\partial z_{j}^{(l)}}<br>$$<br>其中$b_k^{(l+1)}$与$z_j^{(l)}$无关可以省去，$x^{(l+1)}=a^{(l)}=f(z^{(l)})$,因此<br>$$<br>\frac{\partial z_{k}^{(l+1)}}{\partial z_{j}^{(l)}} = W_{kj}^{(l+1)} f’(z_{j}^{(l)})<br>$$<br>$\frac{\partial J(w,b)}{\partial z_{j}^{(l)}}$可以看做损失函数在第l层第i个节点产生的残差量，记为$\delta_{j}^{(l)}$，从而递推公式可以表示为：<br>$$<br>\delta_{j}^{(l)}=(\sum_{k=1}^{S_{l+1}}  W_{kj}^{(l+1)} \delta_{k}^{(l+1)}) f’(z_{j}^{(l)})<br>$$<br>损失对参数函数的梯度可以写为：<br>$$<br>\frac{\partial}{\partial W_{ji}^{(l)}}J(W,b) = \frac{\partial J(w,b)}{\partial z_{j}^{(l)}} \frac{\partial z_{j}^{(l)}}{\partial W_{ji}^{(l)}} = \delta_{j}^{(l)} x_i^{(l)} a_i^{(l-1)}<br>$$<br>$$<br>\frac{\partial}{\partial b_{j}^{(l)}}J(W,b) = \delta_{j}^{(l)}<br>$$<br>下面针对不同的损失函数计算最后一层的残差$\delta^{(L)}$；得到$\delta^{(L)}$之后其他层的残差可以根据递推公式计算。<br>平方误差损失：<br>$$<br>J(W,b)=\frac{1}{2}||y^{(i)}-o^{(i)}||^2 \\<br>\delta^{(L)} = -(y-a^{(L)})f’(z^{(L)})<br>$$<br>交叉熵损失：<br>$$<br>J(W,b)=- \sum_{k=1}^{n}y_k \ln o_k^{(L)} \\<br>\delta^{(L)} = a_k^{(L)}-y_k<br>$$</p>
<h2 id="77-平方误差和交叉熵损失函数分别适合什么场景？"><a href="#77-平方误差和交叉熵损失函数分别适合什么场景？" class="headerlink" title="77 平方误差和交叉熵损失函数分别适合什么场景？"></a>77 平方误差和交叉熵损失函数分别适合什么场景？</h2><p>一般来说，平方损失函数更适合输出为连续，并且最后一层不含Sigmoid或Softmax激活函数的神经网络；交叉熵损失则更适合二分类或多分类的场景。<br>因为平方损失函数相对于输出层的导数为：<br>$$<br>\delta^{(L)} = -(y-a^{(L)})f’(z^{(L)})<br>$$<br>当激活函数为sigmoid时，如果z的绝对值较大，函数的梯度会趋于饱和，即导数绝对值非常小，导致残差也小，使得基于梯度的学习速度非常缓慢。当使用交叉熵损失函数时，相对于输出层的导数（残差）为<br>$$<br>\delta^{(L)} = a_k^{(L)}-y_k<br>$$<br>此时的导数是线性的，因此不会存在学习速度过慢的问题。</p>
<h2 id="78-卷积操作的本质特性包括稀疏交互和参数共享，具体解释这两种特性及其作用。"><a href="#78-卷积操作的本质特性包括稀疏交互和参数共享，具体解释这两种特性及其作用。" class="headerlink" title="78 卷积操作的本质特性包括稀疏交互和参数共享，具体解释这两种特性及其作用。"></a>78 卷积操作的本质特性包括稀疏交互和参数共享，具体解释这两种特性及其作用。</h2><ul>
<li>稀疏交互（Sparse Interaction）<br>在卷积神经网络中，卷积核尺度远小于输入的维度，使得每个输出神经元仅与前一层局部区域内的神经元存在连接权重。<br>它的物理意义是，通常图像、文本、语言等现实世界中的数据都具有局部的特征结构，可以先学习局部的特征，再将局部的特征组合起来形成更复杂和抽象的特征。</li>
<li>参数共享（Parameter sharing）<br>参数共享是指在同一个模型中的不同模块中使用相同的参数。在卷积神经网络中，卷积核中的每一个元素将作用于每一次局部输入的特定位置上。根据参数共享的思想，我们只需要学习一组参数组合，而不需要针对每个位置的每个参数都进行优化，从而大大降低了模型的存储需求。<br>它的物理意义是使得卷积层具有平移不变性，也就是说神经网络的输出对于平移变换来说应当是等变的。</li>
</ul>
<h2 id="79-常见的池化操作有哪些？池化的作用是什么？"><a href="#79-常见的池化操作有哪些？池化的作用是什么？" class="headerlink" title="79 常见的池化操作有哪些？池化的作用是什么？"></a>79 常见的池化操作有哪些？池化的作用是什么？</h2><ul>
<li>均值池化<br>对邻域内特征数值求平均，能够拟制由于邻域大小受限造成估计值方差增大的现象，特点是对背景的保留效果好。</li>
<li>最大池化<br>通过取邻域内特征的最大值来实现，能够拟制网络参数误差造成估计均值偏移的现象，特点是更好地提取纹理信息。</li>
<li>相邻重叠区域的池化<br>是采用比窗口宽度更小的步长，使得窗口在每次滑动时存在重叠的区域。</li>
<li>金字塔池化<br>考虑了多尺度信息的描述，例如同时计算1x1，2x2，4x4的矩阵的池化并将结果拼接在一起作为下一网络层的输入。<br>池化操作能显著降低参数量，并且能保持对平移、伸缩、旋转操作的不变性。</li>
</ul>
<h2 id="80-卷积神经网络如何用于文本分类任务？"><a href="#80-卷积神经网络如何用于文本分类任务？" class="headerlink" title="80 卷积神经网络如何用于文本分类任务？"></a>80 卷积神经网络如何用于文本分类任务？</h2><p>卷积神经网络的核心思想是捕捉局部特征，能够自动地对N-gram特征进行组合和筛选，获得不同抽象层次的语义信息。<br>卷积神经网络有输入层、卷积层、池化层、输出层。<br>（1）输入层是一个NxK的矩阵，其中N为文章所对应的单词总数，K是每个词对应的表示向量的维度。每个词的K维向量可以是预先在其他语料库中训练好的，也可以作为未知的参数有网络训练得到。这两种方法各有优势，一方面，预先训练的词嵌入可以利用其他语料库得到更多的先验知识；另一方面，由当前网络训练的词向量能够更好地抓住与当前任务相关联的特征。<br>（2）第二次维卷积层，定义不同大小的滑动窗口进行卷积操作<br>（3）第三层为池化层<br>（4）接入一个全连接层，使用softmax激活函数输出每个类别的概率。</p>
<h2 id="81-ResNet的提出背景和核心理论是什么？"><a href="#81-ResNet的提出背景和核心理论是什么？" class="headerlink" title="81 ResNet的提出背景和核心理论是什么？"></a>81 ResNet的提出背景和核心理论是什么？</h2><p>ResNet的提出背景是解决或缓解生成的神经网络训练中的梯度消失问题。<br>根据误差传播公式：<br>$$<br>\delta_{i}^{(l)}=(\sum_{j=1}^{S_{l+1}}  W_{ji}^{(l+1)} \delta_{j}^{(l+1)}) f’(z_{i}^{(l)})<br>$$<br>将式再展开一层，可以得到；<br>$$<br>\delta_{i}^{(l)}=(\sum_{j=1}^{S_{l+1}}  W_{ji}^{(l+1)} (\sum_{k=1}^{S_{l+2}}  W_{kj}^{(l+2)} \delta_{k}^{(l+2)} f’(z_{j}^{(l+1)})   ) f’(z_{i}^{(l)})<br>$$<br>可以看到误差传播可以写成参数$W_{ji}^{(l+1)}$、$W_{kj}^{(l+2)}$以及导数$f’(z_{j}^{(l+1)})$、$f’(z_{i}^{(l)})$连乘的形式，当误差由L层传播到除输入以外的第一个隐含层的时候，会涉及到非常多的参数和导数的连乘，这时候误差很容易产生消失或者膨胀，影响该层参数的正确学习，因此深层神经网络的拟合和泛化能力较差。<br>ResNet通过调整网络结构来解决上述问题。将输入短接到两层之后，可以直接学习一个恒等映射，可以有效改善深层的神经网络学习问题。</p>
<h1 id="第10章-循环神经网络"><a href="#第10章-循环神经网络" class="headerlink" title="第10章 循环神经网络"></a>第10章 循环神经网络</h1><h2 id="82-处理文本数据时，循环神经网络与前馈神经网络相比有什么特点"><a href="#82-处理文本数据时，循环神经网络与前馈神经网络相比有什么特点" class="headerlink" title="82 处理文本数据时，循环神经网络与前馈神经网络相比有什么特点?"></a>82 处理文本数据时，循环神经网络与前馈神经网络相比有什么特点?</h2><p>传统文本处理任务的方法中一般讲TF-IDF向量作为特征输入，这样的表示实际上丢失了输入的文本序列中每个单词的顺序。卷积神经网络对文本建模时，输入变长的字符串或者单词串，然后通过滑动窗口加池化的方式将原先的输入转换成一个固定长度的向量表示，这样做可以捕捉到原文本中的一些局部特征，但是两个单词之间的长距离依赖关系还是很难被学习到。<br>一个长度为T的序列用循环神经网络建模，展开之后可以看做是一个T层的前馈神经网络。其中第t层的隐含状态h(t)编码了序列中前t个输入的信息，可以通过当前的输入x(t)和上一层神经网络状态h(t-1)计算得到；最后一层的状态h(T)编码了整个序列的信息，因此可以作为整篇文档的压缩表示，以此为基础的结构可以应用于多种具体任务。例如，在h(T)后面直接接一个Softmax层，输出文本所属类别的预测概率y，就可以实现文本分类。</p>
<h2 id="83-循环神经网络为什么会出现梯度消失或梯度爆炸？有哪些改进方案？"><a href="#83-循环神经网络为什么会出现梯度消失或梯度爆炸？有哪些改进方案？" class="headerlink" title="83 循环神经网络为什么会出现梯度消失或梯度爆炸？有哪些改进方案？"></a>83 循环神经网络为什么会出现梯度消失或梯度爆炸？有哪些改进方案？</h2></div><div class="tags"><a href="/tags/Books-Note/">Books Note</a></div><div class="post-nav"><a class="pre" href="/2019/05/14/概率图模型/">概率图模型</a><a class="next" href="/2019/05/04/聚类算法一览/">聚类算法一览</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/algorithms/" style="font-size: 15px;">algorithms</a> <a href="/tags/Algorithm-practice/" style="font-size: 15px;">Algorithm practice</a> <a href="/tags/machine-learning/" style="font-size: 15px;">machine learning</a> <a href="/tags/Books-Note/" style="font-size: 15px;">Books Note</a> <a href="/tags/Recommendation-System/" style="font-size: 15px;">Recommendation System</a> <a href="/tags/NLP/" style="font-size: 15px;">NLP</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/22/从Seq2seq到Attention模型到Self-Attention/">从Seq2seq到Attention模型到Self Attention</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/20/RNN基础/">RNN基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/01/深度排序模型概述（二）PNN-NFM-AFM/">深度排序模型概述（二）PNN/NFM/AFM</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/28/深度排序模型概述（一）Wide&Deep_xDeepFM/">深度排序模型概述（一）Wide&Deep/xDeepFM</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/27/FM系列/">FM系列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/27/推荐系统概述（二）/">推荐系统概述（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/19/推荐系统概述（一）/">推荐系统概述（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/14/概率图模型/">概率图模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/06/百面机器学习/">百面机器学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/04/聚类算法一览/">聚类算法一览</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="https://github.com/helloJamest" title="github" target="_blank">github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Jamest.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" color="0,0,0" opacity="0.5" zindex="-2" count="50" src="//lib.baomitu.com/canvas-nest.js/2.0.3/canvas-nest.umd.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>